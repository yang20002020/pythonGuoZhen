<head> <meta charset="utf-8" </head>
                      <div id="content_views" class="htmledit_views">
                    <article class="post_article" style="font-size: 16px;"> 
 <h2>二叉树</h2> 
 <p>1.节点定义</p> 
 <pre><code class="has">struct TreeNode{
  ElementType data;			//数据
  TreeNode *leftChild;	//左子树
  TreeNode *rightChild;	//右子树
}</code>



</pre>
 <p>2.前序遍历</p> 
 <pre><code class="has">void PreOrder(TreeNode *root){
  if (root == NULL){
    return;
  }
  visit(root-&gt;data);
  PreOrder(root-&gt;leftChild);
  PreOrder(root-&gt;rightChild);
  return;
}</code>



</pre>
 <p>3.中序遍历</p> 
 <pre><code class="has">void PreOrder(TreeNode *root){
  if (root == NULL){
    return;
  }
  PreOrder(root-&gt;leftChild);
  visit(root-&gt;data);
  PreOrder(root-&gt;rightChild);
  return;
}</code>



</pre>
 <p>4.后序遍历</p> 
 <pre><code class="has">void PreOrder(TreeNode *root){
  if (root == NULL){
    return;
  }
  PreOrder(root-&gt;leftChild);
  PreOrder(root-&gt;rightChild);
  visit(root-&gt;data);
  return;
}</code>



</pre>
 <p>5.层次遍历</p> 
 <pre><code class="has">void LevelOrder(TreeNode *root){
  queue&lt;TreeNode*&gt; myQueue;
  if (root != NULL){
    myQueue.push(root);
  }
  while (!myQueue.empty()){
    TreeNode *current = myQueue.front();
    Queue.pop();
    visit(current-&gt;data);
    if (current -&gt; leftChild != NULL) {
      myQueue.push(current-&gt;leftChild);
    }
    if (current -&gt; rightChild != NULL) {
      myQueue.push(current-&gt;rightChild);
    }
  }
  return;
}</code>
        </pre>
</article>
                </div>
        