<head> <meta charset="utf-8" </head>
                      <div id="content_views" class="htmledit_views">
                    <article class="post_article" style="font-size: 16px;"> 
 <h4>题目描述：</h4> 
 <p>Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point <em>N</em> (0 ≤ <em>N</em>≤ 100,000) on a number line and the cow is at a point <em>K</em> (0 ≤ <em>K</em> ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.</p> 
 <ul><li>Walking: Farmer John can move from any point <em>X</em> to the points <em>X</em> - 1 or <em>X</em> + 1 in a single minute</li><li>Teleporting: Farmer John can move from any point <em>X</em> to the point 2<em>X</em> in a single minute.</li></ul> 
 <p>If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?</p> 
 <h4>输入：</h4> 
 <p>Line 1: Two space-separated integers: <em>N</em> and <em>K</em>.</p> 
 <h4>输出：</h4> 
 <p>Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.</p> 
 <h4>样例输入：</h4> 
 <p>5 17</p> 
 <h4>样例输出：</h4> 
 <p>4</p> 
 <h4>提示：</h4> 
 <p>The fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes.</p> 
 <pre><code class="has">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;

const int MAXN = 100001;		//此处范围得准确，如果小了会报错

bool visit[MAXN];
int step[MAXN];
queue&lt;int&gt; myQueue;

int bfs(int n, int k)
{
	int next, top;
	myQueue.push(n);			//农夫所在初始点入队
	visit[n] = true;			//标记已被访问
	step[n] = 0;				//步数初始为0
	while(!myQueue.empty()){	//队列非空时，执行循环
		top = myQueue.front();	//取出队首
		myQueue.pop();			//弹出队首
		for (int i = 0; i &lt; 3; i++){
			if (i == 0) {
				next = top - 1;
			} else if (i == 1) {
				next = top + 1;
			} else {
				next = top * 2;
			}
			if(next &lt; 0 || next &gt;= MAXN) continue;	//如已出界，则排除该情况
			if(!visit[next]){						//如果改点还未被访问过
				myQueue.push(next);					//入队
				step[next] = step[top] + 1;			//步数+1
				visit[next] = true;					//标记已被访问过
			}
			if(next == k) return step[next];		//当遍历到结果，返回步数
		}
	}
}

int main()
{
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	memset(visit, false, sizeof(visit));
	if (n &gt;= k) 
		printf("%d\n", n - k);
	else 
		printf("%d\n",bfs(n,k));
	return 0;
}</code>
        </pre>
</article>
                </div>
        