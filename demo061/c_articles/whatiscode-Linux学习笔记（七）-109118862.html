<head> <meta charset="utf-8" </head>
                      <div id="content_views" class="htmledit_views">
                    <article class="post_article" style="font-size: 16px;"> 
 <h2>10 Shell基础</h2> 
 <h3>10.1 Shell概述</h3> 
 <ol><li><strong>Shell是什么</strong></li></ol> 
 <ul><li>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序</li><li>外层应用程序-&gt;Shell命令解释器-&gt;内核-&gt;硬件</li><li>Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性强。</li><li>Shell是<strong>解释执行</strong>的脚本语言，在Shell中可以直接调用Linux系统命令。</li></ul> 
 <ol start="2"><li><strong>Shell的分类</strong></li></ol> 
 <ul><li>Bourne Shell：从1979起Unix就开始使用Bourne Shell，Bourne Shell的主文件名为sh。
   <ul><li>Bourne家族主要有：sh、ksh、<strong>Bash</strong>、psh、zsh</li><li>Bash：Bash与sh兼容，Linux就是使用Bash作为用户的基本Shell。</li></ul></li><li>C Shell：C Shell主要是在BSD版的Unix系统当中使用，因其语法和C语言相类似而得名。
   <ul><li>C家族主要包括：csh、tcsh</li></ul></li><li>Shell的两种主要语法类型有Bourne和C，彼此并不兼容。</li></ul> 
 <ol start="3"><li><strong>Linux支持的Shell</strong></li></ol> 
 <ul><li>vim /etc/shells</li></ul> 
 <h3>10.2 Shell脚本的执行方式</h3> 
 <ol><li><strong>输出命令echo</strong></li></ol> 
 <ul><li>命令格式：echo [选项] [输出内容]</li><li>选项： 
   <ul><li>-e 支持反斜杠线控制的字符转换 控制字符 作用 \ 输出\ \a 输出警告音 \b 退格键，也就是向左删除键 \c 取消输出行末的换行符。和“-n”选项一致 \e ESCAPE键 \f 换页符 \n 换行符 \r 回车键 \t 制表符，也就是Tab键 \v 垂直制表符 \0nnn 按照八进制ASCII码表输出字符。 \xhh 按照十六进制ACSII码输出字符。 </li><li>echo -e "\e[1;31m abcd \e[0m" #输出abcd(带颜色)</li><li>30m=黑色，31m=红色，32m=绿色，33m=黄色</li><li>34m=蓝色，35m=洋红，36m=青色，37m=白色</li></ul></li></ul> 
 <ol start="2"><li><strong>第一个脚本</strong></li></ol> 
 <ul><li>vi hello.sh <code class="prettyprint"> #!/bin/bash #每个脚本文件第一行都必须是这个 #注释(养成良好的注释习惯) #The first program #Author: WadeFrank(E-mail：wadefrank@163.com) echo -e “hello world”</code></li></ul> 
 <ol start="3"><li><strong>脚本执行</strong></li></ol> 
 <ul><li>法一：赋予执行权限，直接运行
   <ul><li>chmod 755 hello.sh</li><li>./hello.sh</li></ul></li><li>法二：通过Bash调用执行脚本
   <ul><li>bash hello.sh</li></ul></li></ul> 
 <ol start="4"><li>window下的sh文件转化为Linux下的sh文件</li></ol> 
 <ul><li>dos2unix</li></ul> 
 <h3>10.3 Bash的基本功能</h3> 
 <h4>10.3.1 历史命令与命令补全</h4> 
 <ol><li><strong>历史命令</strong></li></ol> 
 <ul><li>history [选项] [历史命令保存文件]</li><li>选项：
   <ul><li>-c 清空历史命令</li><li>-w 把缓存中的历史命令写入历史命令保存文件 /root/.bash_history</li></ul></li><li>历史命令默认保存1000条，可以在环境变量配置文件/etc/profile中进行修改</li><li>历史命令的调用
   <ul><li>用上下箭头来调用以前的历史命令</li><li>使用"!n"重复执行第n条历史命令</li><li>使用"!!"重复执行上一条命令</li><li>使用"!字串"重复执行最后一条以该字串开头的命令</li></ul></li></ul> 
 <ol start="2"><li><strong>命令与文件补全</strong></li></ol> 
 <ul><li>在输入命令或文件时，按“Tab键”就会自动补全</li></ul> 
 <h4>10.3.2 命令别名与常用快捷键</h4> 
 <ol><li><strong>命令别名(临时生效)</strong></li></ol> 
 <ul><li>alias 别名 = ‘原命令’ #设定命令别名</li><li>alias #查询命令别名</li></ul> 
 <ol start="2"><li><strong>命令执行顺序</strong></li></ol> 
 <ul><li>第一顺位执行用绝对路径或相对路径执行的命令</li><li>第二顺位执行别名</li><li>第三顺位执行Bash的内部命令</li><li>第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令</li></ul> 
 <ol start="3"><li><strong>让别名永久生效</strong></li></ol> 
 <ul><li>vi /root/.bashrc</li></ul> 
 <ol start="4"><li><strong>删除别名</strong></li></ol> 
 <ul><li>unalias 别名</li></ul> 
 <ol start="5"><li><strong>Bash常用快捷键</strong> 快捷键 作用 ctrl+A 把光标移到命令行开头 ctrl+E 把光标移到命令行结尾 ctrl+C 强制终止当前命令 ctrl+L 清屏(=clear命令) ctrl+U 删除或剪切光标之前的命令 ctrl+K 删除或剪切光标之后的命令 ctrl+Y 粘贴ctrl+U或ctrl+K剪切的内容 ctrl+R 在历史命令中搜索，按下ctrl+R之后就会出现搜索界面，只需输入搜索内容，就会从历史命令中搜索 ctrl+D 退出当前终端 ctrl+Z 暂停，并放入后台 ctrl+S 暂停屏幕输出 ctrl+Q 恢复屏幕输出 </li></ol> 
 <h4>10.3.3 输入输出重定向</h4> 
 <ol><li><strong>标准输入输出</strong> 设备 设备文件名 文件描述符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/stdout 1 标准输出 显示器 /dev/stderr 2 标准错误输出 </li><li><strong>输出重定向</strong> 类型 符号 作用 标准输出重定向 命令 &gt; 文件 以<strong>覆盖</strong>的方式，把命令的正确输出保存到指定的文件或者设备中 命令 &gt;&gt; 文件 以<strong>追加</strong>的方式，把命令的正确输出保存到指定的文件或者设备中 标准错误输出重定向 错误命令 2&gt; 文件 以<strong>覆盖</strong>的方式，把命令的错误输出保存到指定的文件或者设备中 错误命令 2&gt;&gt; 文件 以<strong>追加</strong>的方式，把命令的错误输出保存到指定的文件或者设备中 <strong>正确输出和错误输出同时保存</strong> 命令 &gt; 文件 2&gt;&amp;1 以<strong>覆盖</strong>的方式，把命令的正确输出和错误输出保存到同一个文件中 命令 &gt;&gt; 文件 2&gt;&amp;1 以<strong>追加</strong>的方式，把命令的正确输出和错误输出保存到同一个文件中 命令 &amp;&gt;文件 以<strong>覆盖</strong>的方式，把命令的正确输出和错误输出保存到同一个文件中 命令 &amp;&gt;&gt;文件 以<strong>追加</strong>的方式，把命令的正确输出和错误输出保存到同一个文件中 命令 &gt;&gt;文件1 2&gt;&gt;文件2 把正确的输出追加到文件1中，把错误的输出追加到文件2中 </li></ol> 
 <ul><li>/dev/null 垃圾箱</li></ul> 
 <ol start="3"><li><strong>输入重定向</strong></li></ol> 
 <ul><li>wc [选项] [文件名](ctrl+D结束)</li><li>选项：
   <ul><li>-l 统计行数</li><li>-c 统计字节数</li><li>-w 统计单词数</li></ul></li><li>命令 &lt; 文件 #把文件作为命令的输入</li></ul> 
 <h4>10.3.4 多命令顺序执行与管道符</h4> 
 <ol><li><strong>多命令顺序执行</strong> 多命令执行符 格式 作用 ; 命令1;命令2 多个命令顺序执行，命令之间没有任何逻辑联系 &amp;&amp; 命令1&amp;&amp;命令2 逻辑与，命令1正确执行时命令2执行，命令1执行不正确，则命令2不执行 || 命令1||命令2 逻辑或，命令1执行不正确时命令2执行，命令1正确执行时命令2不执行 </li></ol> 
 <ul><li>命令 &amp;&amp; echo yes ||echo no #判断命令是否报错</li></ul> 
 <ol start="2"><li><strong>管道符</strong></li></ol> 
 <ul><li>命令格式：命令1｜命令2 #命令1的正确输出作为命令2的操作对象</li><li>示例：
   <ul><li>ll -a /etc/ ｜more #让命令结果分页表示</li><li>netstat -an｜grep ESTABLISHED #在命令结果中查找已经建立连接的</li></ul></li></ul> 
 <h4>10.3.5 通配符与其他特殊符号</h4> 
 <ol><li>通配符 通配符 作用 ？ 匹配一个任意字符 * 匹配0个或任意多个任意字符，也就是可以匹配任何内容 [] 匹配中括号中任意一个字符。例如：[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c [-] 匹配中括号中任意一个字符，-代表一个范围。例如：[a-z] [^] 逻辑非，表示匹配不是中括号内的一个字符。例如[\^0-9] </li><li>Bash中的其他常用特殊符号 符号 作用 '' 单引号。在单引号中所有的特殊符号，如$和`都没有特殊含义 "" 双引号。在双引号中的特殊符号没有特殊含义，但是$`和\除外。 `` 反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。 $() 和反引号作用一样，用来引用系统命令。 # 注释 $ 用于调用变量的值，如$name \ 转义符 </li></ol> 
 <h3>10.4 Bash的变量</h3> 
 <h4>10.4.1 用户自定义变量</h4> 
 <ol><li><strong>什么是变量</strong></li></ol> 
 <ul><li>变量是计算机内存的单元，其中存放的值可以改变。</li><li>变量可以用于保存有用信息。</li></ul> 
 <ol start="2"><li><strong>变量设置规则</strong></li></ol> 
 <ul><li>变量名称可以由字母、数字和下划线组成，但是不能用数字开头。</li><li>在Bash中，变量的默认类型都是字符串类型，如果要进行数值运算，则必须指定变量类型为数值型。</li><li>变量用等号连接值，等号左右不能有空格。</li><li>变量的值如果有空格，需要用单引号或者双引号包起来。</li><li>在变量的值中，可以使用“\“转义符。</li><li>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包起来”$变量名“或用\${变量名}包含。</li><li>如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含</li><li>环境变量名建议大写，便于区分</li></ul> 
 <ol start="3"><li><strong>变量分类</strong></li></ol> 
 <ul><li>用户自定义变量</li><li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据。</li><li>位置参数变量：这种变量主要是用来向脚本当中传递参数或者数据的，变量名不能自定义，变量作用是固定的。</li><li>预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li></ul> 
 <ol start="4"><li><strong>本地变量</strong>(用户自定义变量)</li></ol> 
 <ul><li>变量定义
   <ul><li>name="feng xian"</li></ul></li><li>变量叠加
   <ul><li>aa=123</li><li>aa="$aa"456</li><li>aa=${aa}789</li></ul></li><li>变量调用：echo $name</li><li>变量查看：set</li><li>变量删除：unset name</li></ul> 
 <h4>10.4.2 环境变量</h4> 
 <ol><li><strong>环境变量是什么？</strong></li></ol> 
 <ul><li>用户自定义变量只在当前的Shell中生效，而环境变量会在当前Shell和这个Shell的所有子Shell当中生效。</li><li>如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效。</li></ul> 
 <ol start="2"><li><strong>设置环境变量</strong></li></ol> 
 <ul><li>export 变量名=变量值 #声明变量</li><li>env #查询变量</li><li>unset 变量名 #删除变量</li><li>pstree #查询继承树</li></ul> 
 <ol start="3"><li><strong>系统常见环境变量</strong></li></ol> 
 <ul><li>PATH：系统查找命令的路径
   <ul><li>echo $PATH </li><li>PATH="$PATH":/root/sh #PATH变量叠加(临时生效)</li></ul></li><li>PS1:定义系统<strong>提示符</strong>的变量
   <ul><li>\d：显示日期，格式为“星期 月 日”</li><li>\h：显示简写主机名。如默认主机名“localhost”</li><li>\t：显示24小时制时间，格式为“HH：MM：SS“</li><li>\T：显示12小时制时间，格式为“HH：MM：SS“</li><li>\A：显示24小时制时间，格式为”HH：MM“</li><li>\u：显示当前用户名</li><li>\w：显示当前所在目录的完整名称</li><li>\W：显示当前所在目录的最后一个目录</li><li>\#：执行的第几个命令</li><li>\$：提示符。如果是root，会显示提示符为“#”，如果是普通用户会显示提示符为“\$“</li></ul></li><li>示例：PS1="[\u@\h \w]\$ "</li><li>Mac：\h:\W \u\$</li></ul> 
 <h4>10.4.3 预定义变量</h4> 
 <ol><li><strong>位置参数变量</strong> 位置参数变量 作用 $n n为数字，\$0代表命令本身，\$1-\$9代表第一到第9个参数，十以上的参数需要用大括号包含，如${10} $* 这个变量代表命令行中的所有参数，$*把所有的参数看成<strong>一个整体</strong> $@ 这个变量也代表命令行中所有的参数，不过$@把每个参数<strong>区分对待</strong> $# 这个变量代表命令行中所有参数的个数 </li></ol> 
 <ul><li>示例1：vi sum <code class="prettyprint"> #!/bin/bash num1=$1 num2=$2 sum=$(($num1 + $num2)) #变量sum的和是num1加num2 echo $sum #打印变量sum的值</code></li></ul> 
 <ol start="2"><li><strong>其他预定义变量</strong> 预定义变量 作用 $? 最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0(具体是哪个数由命令自己来决定)，则证明上一个命令执行不正确 $$ 当前进程的进程号(PID) $! 后台运行的最后一个进程的进程号(PID) </li><li><strong>接收键盘收入</strong></li></ol> 
 <ul><li>read [选项] [变量名]</li><li>选项： 
   <ul><li>-p “提示信息”：在等待read输入时，输出提示信息</li><li>-t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间</li><li>-n 字符数：read命令只接受指定的字符数，就会执行</li><li>-s 隐藏输入的数据，适用于机密信息的输入</li></ul></li><li>示例： <code class="prettyprint"> #!/bin/bash #Author:fengxian read -t 30 -p "Please input your name:" name #提示“输入姓名”并等待30秒，把用户的输入保存入变量name中 echo "Name is $name" read -s -t 30 -p "Please input your age:" age #年龄是隐私，所以我们用“-s“选项隐藏输入 echo "Age is $age" echo -e "\n" read -n 1 -t 30 -p "Please input your gender[M/F]:" gender #使用“-n l”选项只接收一个输入字符 echo -e "\n" echo "Sex is $gender"</code></li></ul> 
 <h3>10.5 Bash的运算符</h3> 
 <h4>10.5.1 数值运算与运算符</h4> 
 <ol><li><strong>declare声明变量类型</strong></li></ol> 
 <ul><li>declare [+/-] [选项] 变量名</li><li>选项：
   <ul><li>- 给变量设定类型属性</li><li>+ 取消变量的类型属性</li><li>-i 将变量声明为整数型(integer)</li><li>-x 将变量声明为环境变量</li><li>-p 显示指定变量的被声明的类型</li></ul></li></ul> 
 <ol start="2"><li><strong>数值运算</strong></li></ol> 
 <ul><li>方法1 <code class="prettyprint"> aa=11 bb=22 declare -i cc=$aa+$bb</code></li><li>方法2：expr或let数值运算工具 <code class="prettyprint"> dd=$(expr $aa + $bb)</code></li><li>方法3："$((运算式))"或"\$[运算式]" <code class="prettyprint"> ff=$(($aa+$bb)) #最常用 gg=$[$aa+$bb]</code></li></ul> 
 <ol start="3"><li><strong>运算符</strong> 优先级 运算符 说明 13 -，+ 单目负、单目正 12 ！，～ 逻辑非、按位取反码或补码 11 *，/，% 乘、除、取模 10 +，- 加、减 9 &lt;&lt;，&gt;&gt; 按位左移、按位右移 8 &lt;=，&gt;=，&lt;，&gt; 小于或等于、大于或等于、小于、大于 7 ==，!= 等于、不等于 6 &amp; 按位与 5 ^ 按位异或 4 | 按位或 3 &amp;&amp; 逻辑与 2 || 逻辑或 1 =,+=,-=,*=,/=,%=,&amp;=,^=,|=,&lt;&lt;=,&gt;&gt;= 赋值、运算后赋值 </li><li><strong>变量测试与内容替换</strong> 变量置换方式 变量y没有设置 变量y为空值 变量y设置值 x=${y-新值} x=新值 x为空 x=$y x=${y:-新值} x=新值 x=新值 x=$y x=${y+新值} x为空 x=新值 x=新值 x=${y:+新值} x为空 x为空 x=新值 x=${y=新值} x=新值；y=新值 x为空；y值不变 x=$y；y值不变 x=${y:=新值} x=新值；y=新值 x=新值；y=新值 x=$y；y值不变 x=${y?新值} 新值输出到标准错误输出(就是屏幕) x为空 x=$y x=${y:?新值} 新值输出到标准错误输出 新值输出到标准错误输出 x=$y </li></ol> 
 <ul><li>例子1:测试x=${y-新值} <code class="prettyprint"> unset y #删除变量 x=${y-new} # 进行测试 echo $x #因为变量y不存在，所以x=new</code></li></ul> 
 <h3>10.6 环境变量配置文件</h3> 
 <h4>10.6.1 环境变量配置文件简介</h4> 
 <ol><li><strong>source命令</strong></li></ol> 
 <ul><li>让配置文件立即生效</li><li>source 配置文件(=. 配置文件)</li></ul> 
 <ol start="2"><li><strong>环境变量配置文件简介</strong></li></ol> 
 <ul><li>环境变量配置文件中主要是定义对系统的操作环境生效的默认环境变量，比如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量</li></ul> 
 <ol start="3"><li><strong>环境变量</strong> /etc目录下的对所有用户生效；~/目录下的只对当前用户生效；越在后面优先级越高。</li></ol> 
 <ul><li>/etc/profile</li><li>/etc/profile.d/*.sh(一组文件)</li><li>~/.bash_profile</li><li>~/.bashrc</li><li>/etc/bashrc</li></ul> 
 <h4>10.6.2 环境变量配置文件作用</h4> 
 <ol><li><strong>/etc/profile的作用</strong></li></ol> 
 <ul><li>USER变量</li><li>LOGNAME变量</li><li>MIAL变量</li><li>PATH变量</li><li>HOSTNAME变量</li><li>umask变量</li><li>调用/etc/profile.d/*.sh文件</li></ul> 
 <ol start="2"><li><strong>~/.bash_profile的作用</strong></li></ol> 
 <ul><li>调用~/.bashrc文件</li><li>在PATH变量后面加入了":$HOME/bin"这个目录</li></ul> 
 <ol start="3"><li><strong>~/.bashrc的作用</strong></li></ol> 
 <ul><li>系统别名</li><li>调用/etc/bashrc文件</li></ul> 
 <ol start="4"><li><strong>/etc/bashrc的作用</strong></li></ol> 
 <ul><li>PS1变量</li><li>umask变量</li><li>PATH变量</li><li>调用/etc/profile.d/*.sh文件</li></ul> 
 <h4>10.6.3 其他配置文件和登录信息</h4> 
 <ol><li>注销时生效的环境变量配置文件</li></ol> 
 <ul><li>~/.bash_logout</li></ul> 
 <ol start="2"><li>其他配置文件</li></ol> 
 <ul><li>~/bash_history(历史命令)</li></ul> 
 <ol start="3"><li>Shell登录信息</li></ol> 
 <ul><li>本地终端欢迎信息：/etc/issue 转义符 作用 \d 显示当前系统日期 \s 显示操作系统名称 \l 显示登录的终端号(比较常用) \m 显示硬件体系结构，如i386、i686等 \n 显示主机名 \o 显示域名 \r 显示内核版本 \t 显示当前系统时间 \u 显示当前登录用户的序列号 </li><li>远程终端欢迎信息：/etc/issue.net 
   <ul><li>转义符在/etc/issue.net文件中不能使用</li><li>是否显示此欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入“Banner /etc/issue.net“行才能显示(记得重启SSH服务)</li></ul></li><li>登录后欢迎信息：/etc/motd 
   <ul><li>不管是本地登陆还是远程登录，都可以显示</li></ul></li></ul> 
 <h2>11 Shell编程</h2> 
 <h3>11.1 基础正则表达式(多练)</h3> 
 <ol><li><strong>正则表达式和通配符</strong></li></ol> 
 <ul><li>正则表达式用来<strong>在文件中</strong>匹配符合条件<strong>字符串</strong>，正则是<strong>包含匹配</strong>。grep、awk、sed等命令可以支持正则表达式。</li><li>通配符用来<strong>在系统中</strong>匹配符合条件的<strong>文件名</strong>，通配符是<strong>完全匹配</strong>。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配。</li></ul> 
 <ol start="2"><li><strong>基础正则表达式</strong> 元字符 作用 * 前一个字符匹配<strong>0次</strong>或任意多次 . 匹配除了换行符外任意一个字符 ^ 匹配行首。例如：^hello会匹配以hello开头的行 $ 匹配行尾。例如：hello$会匹配以hello结尾的行 [] 匹配中括号指定的<strong>任意一个字符</strong>，只匹配一个字符。例如：[aeiou]匹配任意一个元音字母，[0-9]匹配任意一位数字，[a-z][0-9]匹配小写字和一位数字构成的两位字符。不匹配换行符(即空白行)。 [^] 匹配中括号的字符以外的<strong>任意一个字符</strong>。例如：[\^0-9]匹配任意一位非数字字符。不匹配换行符(即空白行)。 \ 转义符。 \{n\} 表示其前面的字符恰好出现n次。例如：[0-9]\{4\}匹配4位数字，[1][3-8][0-9]\{9\}匹配手机号码 \{n,\} 表示其前面的字符出现不小于n次。例如：[0-9]\{2,\}表示两位及以上的数字。 \{n,m\} 表示其前面的字符至少出现n次，最多出现m次。例如[a-z]\{6,8\}匹配6到8位的小写字母。 </li></ol> 
 <ul><li>示例：
   <ul><li>*</li><li>grep "a*" test_rule.txt #匹配所有内容，包括空白行</li><li>grep "aa*" test_rule.txt #匹配至少含有一个a的行</li><li>.</li><li>grep "s..d" test_rule.txt #匹配在s和d这两个字母之间一定有两个字符的单词</li><li>grep "s.*d" test_rule.txt #匹配在s和d这两个字母之间有任意字符的单词</li></ul></li></ul> 
 <h3>11.2 字符截取命令</h3> 
 <ol><li><strong>cut</strong>字段提取命令</li></ol> 
 <ul><li>cut [选项] 文件名</li><li>选项：
   <ul><li>-f 列号 #提取第几列</li><li>-d 分隔符 #按照指定分隔符分割列</li></ul></li><li>示例：
   <ul><li>cut -f 2 student.txt</li></ul></li><li>cut命令的局限
   <ul><li>只适用于制表符或者：和，和。分隔的比较标准的列。</li><li>不适用于空格作为分隔符的文件</li></ul></li></ul> 
 <ol start="2"><li><strong>printf</strong>命令</li></ol> 
 <ul><li>printf '输出类型输出格式' 输出内容</li><li>输出类型：
   <ul><li>%ns #输出字符串。n是数字，表示输出几个字符。</li><li>%ni #输出整数。n是数字，表示输出几个数字。</li><li>%m.nf #输出浮点数。m和n是数字，表示输出的整数位数和小数位数。</li></ul></li><li>输出格式：
   <ul><li>\a #输出警告声音</li><li>\b #输出退格键(backspace)</li><li>\f #清除屏幕</li><li>\n #换行</li><li>\r #回车(enter)</li><li>\t #水平输出退格键(tab)</li><li>\v #垂直输出退格键(tab)</li></ul></li><li>print会自动加上换行符，而printf则需要手动添加</li></ul> 
 <ol start="3"><li><strong>awk</strong>命令</li></ol> 
 <ul><li>awk '条件1{动作1} 条件2 {动作2} …' 文件名</li><li>条件(pattern)：
   <ul><li>一般使用关系表达式作为条件(如x&gt;10,x&lt;=10等)</li><li>BEGIN</li><li>在处理之前先执行一个动作</li><li>awk 'BEGIN{printf"This is a transcript \n"} {printf $2 "\t" \$6"\n"}' student.txt</li><li>END</li><li>在所有动作完成之后，在执行一个动作</li></ul></li><li>动作(action)：
   <ul><li>格式化输出</li><li>流程控制语句</li></ul></li><li>示例
   <ul><li>awk '{printf $2 "\t" \$6"\n"}' student.txt #无条件完成动作输出第2列和第6列</li></ul></li></ul> 
 <ol start="4"><li><strong>sed</strong>命令</li></ol> 
 <ul><li>sed是一种存在于几乎所有Unix平台上的轻量级流编辑器。</li><li>sed主要是用来将数据进行选取、替换、删除、新增的命令。</li><li>sed [选项] '[动作]' 文件名</li><li>选项：
   <ul><li>-n 一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则<strong>只会把经过sed命令处理的行输出到屏幕</strong>。</li><li>-e 允许对输入数据应用多条sed命令编辑，用；隔开</li><li>-i 用sed的修改结果<strong>直接修改读取数据的文件</strong>，而不是由屏幕输出</li></ul></li><li>动作：
   <ul><li>a 追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用"\"代表数据未完结。</li><li>c 行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用"\"代表数据未完结</li><li>i 插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用"\"代表数据未完结。</li><li>d 删除，删除指定的行。</li><li>p 打印，输出指定的行。</li><li>s 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”(和vim中的替换格式类似)。</li></ul></li><li>示例：
   <ul><li>sed -n '2p' student.txt #查看文件的第二行</li><li>df -h |sed -n '2p'</li><li>sed '2a hello' student.txt #在第二行后追加hello</li><li>sed '2i hello \ world' #在第二行前插入两行数据</li></ul></li></ul> 
 <h3>11.3 字符处理命令</h3> 
 <ol><li>排序命令<strong>sort</strong></li></ol> 
 <ul><li>sort [选项] 文件名</li><li>选项：
   <ul><li>-f 忽略大小写</li><li>-n 以数值型进行排序，默认使用<strong>字符串型</strong>排序</li><li>-r 反向排序</li><li>-t 指定分隔符，默认分隔符是制表符</li><li>-k n[,m] 按照指定的字段范围排序。从第n字段开始，m字段结束(默认到行尾)</li></ul></li><li>示例：
   <ul><li>sort /etc/passwd #排序用户信息文件</li><li>sort -r /etc/passwd #反向排序</li><li>sort -t ":" -k 3,3 /etc/passwd #指定分隔符是”：“，用第三字段开头和结尾排序</li></ul></li></ul> 
 <ol start="2"><li>统计命令wc</li></ol> 
 <ul><li>wc [选项] [文件名](ctrl+D结束)</li><li>选项： 
   <ul><li>-l 统计行数</li><li>-c 统计字节数</li><li>-w 统计单词数</li></ul></li></ul> 
 <h3>11.4 条件判断</h3> 
 <ol><li>按照<strong>文件类型</strong>进行判断 测试选项 作用 -b 文件 判断该文件是否存在，并且是否为块设备文件(是为真) -c 文件 判断该文件是否存在，并且是否为字符设备文件(是为真) <strong>-d 文件</strong> 判断该文件是否存在，并且是否为目录文件(是为真) <strong>-e 文件</strong> 判断该文件是否存在(是为真) <strong>-f 文件</strong> 判断该文件是否存在，并且是否为普通文件(是为真) -L 文件 判断该文件是否存在，并且是否为符合链接文件(是为真) -p 文件 判断该文件是否存在，并且是否为管道文件(是为真) -s 文件 判断该文件是否存在，并且是否为非空(是为真) -S文件 判断该文件是否存在，并且是否为套接字文件(是为真) </li></ol> 
 <ul><li>两种判断格式：
   <ul><li>test -e /root/install.log #判断文件是否存在</li><li>[ -e /root/install.log ] #判断文件是否存在，shell脚本中更常用</li><li>$? #判断上一条命令是否执行正确，正确为0，不正确为非0</li></ul></li><li>示例：
   <ul><li>[ -d /root ] &amp;&amp; echo "yes" || echo "no" #第一个判断命令如果正确执行，则打印“yes”，否则打印“no”</li></ul></li></ul> 
 <ol start="2"><li>按照<strong>文件权限</strong>进行判断 测试选项 作用 <strong>-r 文件</strong> 判断该文件是否存在，并且是否该文件拥有读权限(是为真) <strong>-w 文件</strong> 判断该文件是否存在，并且是否该文件拥有写权限(是为真) <strong>-x 文件</strong> 判断该文件是否存在，并且是否该文件拥有执行权限(是为真) -u 文件 判断该文件是否存在，并且是否该文件拥有SUID权限(是为真) -g 文件 判断该文件是否存在，并且是否该文件拥有SGID权限(是为真) -k 文件 判断该文件是否存在，并且是否该文件拥有SBit权限(是为真) </li><li>两个文件之间进行比较 测试选项 作用 文件1 -nt 文件2 判断文件1的修改时间是否比文件2的新(是为真) 文件1 -ot 文件2 判断文件1的修改时间是否比文件2的旧(是为真) 文件1 -ef 文件2 判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。可以用于判断硬链接。 </li><li>两个整数之间比较 测试选项 作用 整数1 -eq 整数2 判断整数1是否和整数2相等(是为真) 整数1 -ne 整数2 判断整数1是否和整数2不相等(是为真) 整数1 -gt 整数2 判断整数1是否大于整数2(是为真) 整数1 -lt 整数2 判断整数1是否小于整数2(是为真) 整数1 -ge 整数2 判断整数1是否大于等于整数2(是为真) 整数1 -le 整数2 判断整数1是否小于等于整数2(是为真) </li></ol> 
 <ul><li>示例：[ 23 -gt 22 ] &amp;&amp; echo "yes" || echo "no"</li></ul> 
 <ol start="5"><li>字符串的判断 测试选项 作用 -z 字符串 判断字符串是否为空(是为真) -n 字符串 判断字符串是否为非空(是为真) 字符串1 == 字符串2 判断字符串1是否和字符串2相等(是为真) 字符串1 != 字符串2 判断字符串1是否和字符串2不相等(是为真) </li></ol> 
 <ul><li>示例：
   <ul><li>name =sc</li><li>[ -z "$name" ] &amp;&amp; echo "yes" || echo "no"</li></ul></li></ul> 
 <ol start="6"><li>多重条件判断 测试选项 作用 判断1 -a 判断2 逻辑与，判断1和判断2都成立，最终的结果才为真 判断1 -o 判断2 逻辑或，判断1和判断2有一个成立，最终的结果就为真 ! 判断 逻辑非，使原始的判断式取反 </li></ol> 
 <h3>11.5 流程控制</h3> 
 <h4>11.5.1 if语句</h4> 
 <ol><li><strong>单分支if条件语句</strong></li></ol> 
 <pre><code class="has">   if [ 条件判断式 ];then
       程序
   fi

   或者：
   if [ 条件判断式 ]
       then
           程序
   fi</code>



</pre>
 <ul><li>示例1：判断分区使用率 <code class="prettyprint"> #!/bin/bash #统计根分区使用率 #Author: fengxian rate=$(df -h | grep "/dev/vda1" | awk '{print $5}' | cut -d "%" -f1) #把根分区使用率作为变量值赋予变量rate if [ $rate -ge 10 ] then echo "Warning! /dev/sda3 is full!!" fi</code></li></ul> 
 <ol start="2"><li><strong>双分支if语句</strong></li></ol> 
 <pre><code class="has">   if [ 条件判断式 ]
       then
           程序
     else
         程序
   fi</code>



</pre>
 <ul><li>示例2：备份mysql数据库 <code class="prettyprint"> #!/bin/bash #备份mysql数据库 #Author: Fengxian ntpdate asia.pool.ntp.org $&gt;/dev/null #同步系统时间 date=$(date +%y%m%d) #把当前系统时间按照“年月日”格式赋予变量date size=$(du -sh /var/lib/mysql) #统计mysql数据库的大小，并把大小赋予size变量 if [ -d /tmp/dbbak ] then echo "Date:$date!" &gt; /tmp/dbbak/dbinfo.txt echo "Date size:$size" &gt;&gt; /tmp/dbbak/dbinfo.txt cd /tmp/dbbak tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null rm -rf /tmp/dbbak/dbinfo.txt else mkdir /tmp/dbbak echo "Date:$date!" &gt; /tmp/dbbak/dbinfo.txt echo "Date size:$size" &gt;&gt; /tmp/dbbak/dbinfo.txt cd /tmp/dbbak tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null rm -rf /tmp/dbbak/dbinfo.txt fi</code></li><li>示例3：判断apache是否启动 <code class="prettyprint"> #!/bin/bash #判断apache是否启动 #Author: Fengxian port=$(nmap -sT 192.168.1.156 | grep tcp | grep http | awk '{print $2}') #使用nmap命令扫描服务器，并截取apache服务的状态，赋予变量port if [ "$port" == "open" ] then echo "$(date) httpd is ok!" &gt;&gt; /tmp/autostart-acc.log else /etc/rc.d/init.d/http start &amp;&gt;/dev/null echo "$(date) restart httpd !!" &gt;&gt; /temp/autostart-err.log fi</code></li></ul> 
 <ol start="3"><li><strong>多分支if条件语句</strong></li></ol> 
 <pre><code class="has">   if [ 条件判断式1 ]
       then
           程序
   elif [ 条件判断式2 ]
     then
         程序
   …
   else
     程序
   fi</code>



</pre>
 <ul><li>示例4： <code class="prettyprint"> #!/bin/bash #判断用户输入的是什么文件 #Author: Fengxian read -p "Please input a filename: " file #接收键盘的输入，并赋予变量file if [ -z "$file" ] #判断file变量是否为空 then echo "Error, please input a filename!" exit 1 elif [ ! -e "$file" ] #判断file的值是否存在 then echo "Your input is not a file!" exit 2 elif [ -f "$file" ] #判断file是否为普通文件 then echo "$file is a regular file!" elif [ -d "$file" ] #判断file的值是否为目录文件 then echo "$file is a directory!" else echo "$file is an other file!" fi</code></li></ul> 
 <h4>11.5.2 case语句</h4> 
 <ol><li>多分支case条件语句</li></ol> 
 <ul><li>case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支语句不同的是，case语句只能判断<strong>一种条件关系</strong>，而if语句可以判断多种条件关系。</li></ul> 
 <ol start="2"><li>case格式</li></ol> 
 <pre><code class="has">   case $变量名 in
       "值1")
           如果变量的值等于值1，则执行程序1
           ;;
     "值2")
       如果变量的值等于值2，则执行程序2
       ;;
     …省略其他分支…
     *)
       如果变量的值都不是以上的值，则执行此程序
       ;;
   esac</code>



</pre>
 <ul><li>示例1 <code class="prettyprint"> #!/bin/bash #判断用户输入 #Author: Fengxian read -p "Please choose yes/no " -t 30 cho case $cho in "yes") echo "Your choose is yes!" ;; "no") echo "Your choose is no!" ;; *) echo"Your choose is error!" ;; esac</code></li></ul> 
 <h4>11.5.3 for循环</h4> 
 <ol><li><strong>语法1</strong></li></ol> 
 <pre><code class="has">   for 变量 in 值1 值2 值3
       do
       程序
     done</code>



</pre>
 <ul><li>示例1: <code class="prettyprint"> #!/bin/bash #打印时间 #Author: Fengxian for time in morning noon afternoon evening do echo "This time is $time" done</code></li><li>示例2 <code class="prettyprint"> #!/bin/bash #批量解压缩脚本 #Author: Fengxian cd /lamp ls *.tar.gz &gt; ls.log for i in $(cat ls.log) do tar -zxf $i &amp;&gt;/dev/null done rm -rf /lamp/ls.log</code></li></ul> 
 <ol start="2"><li><strong>语法2</strong></li></ol> 
 <pre><code class="has">   for ((初始值;循环控制条件;变量变化))
     do
       程序
     done</code>



</pre>
 <ul><li>示例3: <code class="prettyprint"> #!/bin/bash #从1加到100 #Author: Fengxian s=0 for((i=1;i&lt;=100;i=i+1)) do s=$(($s+$i)) done echo "The sum of 1+2+...+100 is $s"</code></li><li>示例4 <code class="prettyprint"> #!/bin/bash #批量添加用户 #Author: Fengxian read -p "Please input user name: " -t 30 name read -p "Please input the number of users: " -t 30 num read -p "Please input the password: " -t 30 pass if [ ! -z "$name" -a ! -z "$num" -a ! -z "$pass" ] then y=$(echo $num|sed's/[0-9]//g') if [-z "$y" ] then for((i=1;i&lt;=$num;i=i+1)) do /usr/sbin/useradd $name$i &amp;&gt;/dev/null echo $pass|/usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null done fi fi</code></li></ul> 
 <h4>11.5.4 while循环和until循环</h4> 
 <ol><li>while</li></ol> 
 <ul><li>while循环是不定循环，也称作条件循环。</li><li>只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。</li></ul> 
 <ol start="2"><li>while格式</li></ol> 
 <pre><code class="has">   while [ 条件判断式 ]
     do
       程序
     done</code>



</pre>
 <ul><li>示例1: <code class="prettyprint"> #!/bin/bash #从1加到100 #Author: Fengxian i=1 s=0 while [ $i -le 100 ] #如果变量i的值小于等于100，则执行循环 do s=$(($s+$i)) i=$(($i+1)) done echo "The sum is: $s"</code></li></ul> 
 <ol start="3"><li>until循环</li></ol> 
 <ul><li>和while循环相反。</li><li>until循环只要条件判断式不成立则进行循环，一旦循环条件成立，则终止循环。</li></ul> 
 <ol start="4"><li>until格式</li></ol> 
 <pre><code class="has">   until [ 条件判断式 ]
     do
       程序
     done</code>
        </pre>
</article>
                </div>
        