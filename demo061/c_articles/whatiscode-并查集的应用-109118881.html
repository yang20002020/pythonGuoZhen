<head> <meta charset="utf-8" </head>
                      <div id="content_views" class="htmledit_views">
                    <article class="post_article" style="font-size: 16px;"> 
 <p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通(但不一定有直接的道路相连，只要互相间接通过道路可达即可)。问最少还需要建设多少条道路？</p> 
 <p>输入描述：</p> 
 <p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 注意:两个城市之间可以有多条道路相通,也就是说 3 3 1 2 1 2 2 1 这种输入也是合法的 当N为0时，输入结束，该用例不被处理。</p> 
 <p>输出描述：</p> 
 <p>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p> 
 <pre><code class="has">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

const int MAXN = 1000;

int father[MAXN];    //父亲结点
int height[MAXN];    //结点高度

void initial(int n){        //初始化
    for (int i = 0; i &lt;= n; i++){
        father[i] = i;        //每个结点的父亲为自己
        height[i] = 0;        //每个结点的高度为0
    }
}

int Find(int x){            //查找根结点
    if (x != father[x]) {    //路径压缩
        father[x] = Find(father[x]);
    }
    return father[x];
}

void Union(int x, int y){    //合并集合
    x = Find(x);
    y = Find(y);
    if (x != y){
        if (height[x] &lt; height[y]){    //矮树作为高树的子树
            father[x] = y;
        } else if (height[y] &lt; height[x]){
            father[y] = x;
        } else {
            father[y] = x;
            height[x]++;
        }
    }
    return;
}

int main(){
    int n, m;
    while (scanf("%d", &amp;n) != EOF){
        if (n == 0){
            break;
        }
        scanf("%d", &amp;m);
        initial(n);				//初始化
        while (m--){
            int x, y;
            cin &gt;&gt; x &gt;&gt; y;
            Union(x, y);		//合并集合
        }
        int answer = -1;
        for (int i = 1; i &lt;= n; i++){
            if (Find(i) == i){		//集合数目
                answer++;
            }
        }
        printf("%d\n", answer);
    }
    return 0;
}</code>



</pre>
</article>
                </div>
        