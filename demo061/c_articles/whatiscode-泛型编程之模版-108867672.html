<head> <meta charset="utf-8" </head>
                      <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>泛型编程</h2> 
<p>面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在<strong>程序运行之前</strong>都未知的情况；而在泛型编程中，在<strong>编译</strong>时就能获知类型了。（这句话还得慢慢去理解）</p> 
<p><strong>模板是C++中泛型编程的基础。<strong>一个模板就是一个创建类或者函数的</strong>蓝图</strong>或者说<strong>公式</strong>。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。</p> 
<h3><a id="1__6"></a>1 函数模板</h3> 
<h4><a id="_8"></a>函数模板的定义</h4> 
<p>假定我们希望编写一个函数来比较两个变量的大小，在实际中，由于变量的类型不同，我们可能需要定义多个重载函数，比如下面两种：</p> 
<pre><code class="prism language-C++">//比较两个变量v1，v2的大小，相等返回0，v1大返回1，v2大返回-1
int compare(const string &amp;v1, const string &amp;v2)
{
    if (v1 &lt; v2) return -1;
    if (v2 &lt; v1) return 1;
    return 0;
}

int compare(const double &amp;v1, const double &amp;v2)
{
    if (v1 &lt; v2) return -1;
    if (v2 &lt; v1) return 1;
    return 0;
}
</code></pre> 
<p>这两个函数几乎是相同的，唯一的差异是参数的类型，函数体完全一样。为了避免重复定义，我们可以定义一个通用的<strong>函数模板（function template）</strong>，compare的函数模板可以定义如下：</p> 
<pre><code class="prism language-c++">template &lt;typename T&gt;
int compare(const T &amp;v1, const T &amp;v2)
{
    if (v1 &lt; v2) return -1;
    if (v2 &lt; v1) return 1;
    return 0;
}
</code></pre> 
<p>函数模板需要注意一下几点：</p> 
<ul><li>在模板定义中，模板参数列表（也就是尖括号里面的部分）不能为空。</li><li>类型参数（也就是T）前必须使用关键字class或者typename（两者可以互换使用）。</li></ul> 
<h4><a id="_46"></a>函数模板的实例化</h4> 
<p>当我们调用一个模板函数时，编译器可以通过函数实参来为我们推断模板实参的类型。比如在下面的调用中：</p> 
<pre><code class="prism language-C++">cout &lt;&lt;  compare(1, 0) &lt;&lt; endl;	//T为int
</code></pre> 
<p>实参类型为int，编译器会推断出模板实参为int，并将它绑定到模板参数T。</p> 
<p>编译器也会用推断出的模板参数来为我们 <strong>实例化（instantiate)</strong> 一个特定版本的函数，如下：</p> 
<pre><code class="prism language-c++">int compare(const int &amp;v1, const int &amp;v2)
{
	if (v1 &lt; v2) return -1;
    if (v2 &lt; v1) return 1;
    return 0;
}
</code></pre> 
<p>这些编译器生成的版本通常被成为模板的<strong>实例（instantiation）</strong>。</p> 
<h3><a id="2__71"></a>2 类模板</h3> 
<p><strong>类模板（class template）</strong> 是用来生成类的蓝图的。与函数模板不同的是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名之后的尖括号提供额外信息（比如vector&lt;int&gt;）。</p> 
<h4><a id="_75"></a>类模板的定义</h4> 
<p>假定我们希望定义一个名为Blob的模板，保存一组元素。与容器不同，我们希望Blob对象的不同拷贝之间共享相同的元素。即，当我们拷贝一个Blob时，原Blob对象及其拷贝应该引用相同的底层元素。Blob模板定义如下：</p> 
<pre><code class="prism language-c++">template &lt;typename T&gt; class Blob {
public:
    typedef T value_type;
    typedef typename std::vector&lt;T&gt;::size_type size_type;
    // 构造函数
    Blob();
    Blob(std::initializer_list&lt;T&gt; il);
    // Blob中的元素数目
    size_type size() const { return data-&gt;size(); }
    bool empty() const { return data-&gt;empty(); }
    // 添加和删除元素
    void push_back(const T &amp;t) { data-&gt;push_back(t);}
    // 移动版本
    void push_back(T &amp;&amp;t) { data-&gt;push_back(std::move(t)); }
    void pop_back();
    T&amp; back();
    T&amp; operator[](size_type i);
private:
    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;
    // 若data[i]无效，则抛出msg
    void check(size_type i, const std::string &amp;msg) const;
};
</code></pre> 
<h4><a id="_104"></a>类模板的实例化</h4> 
<p>当使用一个类模板时，我们必须提供额外信息，即<strong>显式模板实参（explicit template argument）</strong> 列表，它们被绑定模板参数。编译器使用这些模板实参来实例化出特定的类。比如，下面是Blob模板实例化的一个例子：</p> 
<pre><code class="prism language-C++">Blob&lt;int&gt; ia;									//空Blob&lt;int&gt;
Blob&lt;int&gt; ia2 = {0, 1, 2, 3, 4}		//有5个元素的Blob&lt;int&gt;
</code></pre> 
<h3><a id="3__115"></a>3 成员模板</h3> 
<p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为<strong>成员模板（member template）</strong>。成员模板不能是虚函数。</p> 
<h4><a id="_119"></a>普通类的成员模板</h4> 
<pre><code class="prism language-c++">class DebugDelete {
public:
    DebugDelete(std::ostream &amp;s = std::cerr) : os(s) { }
    // 与任何函数模板相同，T的类型由编译器推断
    template &lt;typename T&gt; void operator()(T *p) const { os &lt;&lt; "deleting unique_ptr"} &lt;&lt; std::endl;  delete p; }
private:
	std::ostream &amp;os;
};
</code></pre> 
<h4><a id="_134"></a>类模板的成员模板</h4> 
<pre><code class="prism language-c++">template &lt;typename T&gt; class Blob {
    template &lt;typename It&gt; Blob(It b, It e);
    //...
};
</code></pre>
                </div>
                