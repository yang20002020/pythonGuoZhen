<head> <meta charset="utf-8" </head>
                      <div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h1><a id="_0"></a>动态内存与智能指针</h1> 
<h2><a id="1__2"></a>1 对象和内存</h2> 
<h4><a id="_4"></a>程序中对象的种类和生命周期</h4> 
<ul><li><strong>全局对象</strong>：在程序启动时分配，在程序结束时销毁。</li><li><strong>局部自动对象</strong>：在进入定义它的程序块时被创建，在离开块时销毁。</li><li><strong>局部static对象</strong>：在第一次使用前分配，在程序结束时销毁。</li><li><strong>动态分配对象</strong>：动态分配的对象的生存期由程序来控制，只有当它们被程序显式地释放时，这些对象才会被销毁。</li></ul> 
<h4><a id="_11"></a>内存的种类</h4> 
<ul><li> <p><strong>静态内存</strong>：用来存放局部static对象、类static数据成员以及定义在任何函数之外的变量。</p> </li><li> <p><strong>栈内存</strong>：用来存放定义在函数内的非static对象。</p> </li><li> <p><strong>内存池</strong>（自由空间、<strong>堆</strong>）：用来存储动态分配的对象，即那些在程序运行时分配的对象。</p> </li></ul> 
<p>【注】分配在静态或栈内存中的对象由编译器自动创建和销毁，而堆中的动态对象则需要我们在代码中显式销毁。</p> 
<h2><a id="2__22"></a>2 动态内存的管理</h2> 
<p>在C++中，动态内存的管理是通过一对运算符来完成的：</p> 
<ul><li><strong>new</strong>：在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化。</li><li><strong>delete</strong>：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</li></ul> 
<h2><a id="3__31"></a>3 智能指针</h2> 
<p>由于动态内存的使用很容易出现问题，因为确保在正确的时间释放内存是非常困难的。有时候我们会忘记释放内存，在这种情况下就会产生内存泄漏；有时候在尚有指针应用内存的情况下我们就释放了它，这种情况下就会产生引用非法内存的指针。</p> 
<p>为了更容易、更安全的使用动态内存，C++11提供了两种智能指针（smart point）类型来管理动态对象，都在头文件之中。智能指针的行为类似于常规指针，重要的区别是它负责<strong>自动释放</strong>所指向的对象。</p> 
<ul><li><strong>shared_ptr</strong>：允许多个指针指向同一个对象。</li><li><strong>unique_ptr</strong>：该指针“独占”所指向的对象。</li></ul> 
<p><strong>shared_ptr和unique_ptr都支持的操作</strong>：</p> 
<table><thead><tr><th>代码</th><th>操作</th></tr></thead><tbody><tr><td>shared_ptr&lt;T&gt; sp</td><td>创建一个空智能指针（共享），可以指向类型为T的对象</td></tr><tr><td>unique_ptr&lt;T&gt; up</td><td>创建一个空智能指针（独占），可以指向类型为T的对象</td></tr><tr><td>p</td><td>将p用作一个条件判断，若p指向一个对象，则为true</td></tr><tr><td>*p</td><td>解引用，或者p指向的对象</td></tr><tr><td>p-&gt;mem</td><td>等价于(*p).mem</td></tr><tr><td>p.get()</td><td>返回p中保存的指针。要小心使用，若智能释放了其对象，返回的指针所指向的对象也就消失了</td></tr><tr><td>swap(p,q)</td><td>交换p和q中的指针</td></tr><tr><td>p.swap(q)</td><td>同上</td></tr></tbody></table>
<p><strong>shared_ptr独有的操作</strong>：</p> 
<table><thead><tr><th>代码</th><th>操作</th></tr></thead><tbody><tr><td>make_shared&lt;T&gt;(args)</td><td>返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象。</td></tr><tr><td>shared_ptr&lt;T&gt; p(q)</td><td>p是shared_ptr q的拷贝；此操作会递增q中的引用计数。q中的指针必须能够转换为T*</td></tr><tr><td>p = q</td><td>p和q都是shared_ptr，所保存的指针必须能够互相转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数为0，则将其管理的原内存释放</td></tr><tr><td>p.unique()</td><td>若p.use_count()为1，返回true，否则返回false</td></tr><tr><td>p.use_count()</td><td>返回与p共享对象的智能指针数量；可能很慢，主要用于调试</td></tr></tbody></table>
<h4><a id="_65"></a>智能指针的创建和初始化</h4> 
<p>类似于vector，智能指针也是模版。因此，当我们创建一个智能指针时，必须在尖括号内给出类型。</p> 
<pre><code class="prism language-C++">shared_ptr&lt;string&gt; p1;		//创建一个指向string的智能指针
shared_ptr&lt;list&lt;int&gt;&gt; p2;	//创建一个指向list&lt;int&gt;的智能指针
</code></pre> 
<p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</p> 
<pre><code class="prism language-C++">shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);				//指向一个值为42的int的shared_ptr
shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10, '9'); 	//指向一个值为“9999999999”的string的shared_ptr
shared_ptr&lt;string&gt; p5 = make_shared&lt;int&gt;();				//p5指向一个值初始化的int，即值为0
auto p6 = make_shared&lt;vector&lt;string&gt;&gt;();				//也可以用auto来定义一个shared_ptr对象
</code></pre>
                </div>
                